---
title: 二路归并、梵塔
tags: 算法
categories:
- 算法
- 算法设计与分析
cover: https://tva1.sinaimg.cn/large/e6c9d24ely1h06abvsgjsj20km0deq3f.jpg
---

# 递归算法的时间复杂度分析

## 分析过程

递归算法时间复杂度的分析称为**变长**时间复杂度的分析

- 递归算法时间复杂度分析的关键：根据递归过程建立**递推关系式**
- 然后求解这个递推关系式，得到一个表示算法执行时间的表达式
- 最后用渐进符号来表示这个表达式即得到算法的时间复杂度

## 算法1—二路归并排序

```c++
void mergeSort(int a[], int i, int j){
    int m;
    if ( i != j ){
        m = ( i + j ) / 2;
        mergeSort(a, i, m);
        mergeSort(a, m+1, j);
        merge(a,i,j,m);
    }
}
```

### 分析

1、其中，mergeSort( )用于数组a[0...n-1]（n=2^k，k为正整数）的归并排序，调用该算法的方式为：

- ``mergeSort(a, 0, n-1)；``

2、merge(a, i, j, m)用于两个有序子序列a[i...j]a[j+1...m]的有序合并，是非递归函数，它的时间复杂度为O(n)（这里n=j-i+1）

**解：**设调用mergesort(a,0,n-1)的执行时间为T(n)，由其执行过程得到以下求执行时间的递归关系(递推关系式)：

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h066z12jhcj20tl06imxn.jpg" style="zoom: 33%;" />

- 其中，O(n)为merge( )所需的时间，设为cn(c为正常量)，因此：

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0671w8h2yj21wx0ro76w.jpg" style="zoom:25%;" />

## 算法2—梵塔问题

```c++
void Hanoi(int n, char x, char y, char z){
    if (n == 1) printf("将盘片%d从%c搬到%c\n",n,x,z);
    else {
        Hanoi(n-1, x, z, y);
        printf("将盘片%d从%c搬到%c\n",n,x,z);
        Hanoi(n-1, y, x, z);
    }
}
```

### 分析

**解：**设调用Hanoi(n,x,y,z)的执行时间为T(n)，由其执行过程得到以下求执行时间的递归关系(递推关系式)：

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h06a68yx8lj20o106dglt.jpg" style="zoom: 33%;" />

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h06a8estayj216l0ok75p.jpg" style="zoom: 25%;" />