<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java面试题第二季 | 小新's Blog</title><meta name="keywords" content="面试"><meta name="author" content="小新,1096463510@qq.com"><meta name="copyright" content="小新"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Volatilevolatile是Java虚拟机提供的轻量级的同步机制。  保证可见性 不保证原子性 禁止指令重排  保证可见性JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。  可见性 原子性 有序性  JMM关于同步的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题第二季">
<meta property="og:url" content="https://liuwqtech.github.io/2023/04/02/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%AD%A3/index.html">
<meta property="og:site_name" content="小新&#39;s Blog">
<meta property="og:description" content="Volatilevolatile是Java虚拟机提供的轻量级的同步机制。  保证可见性 不保证原子性 禁止指令重排  保证可见性JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。  可见性 原子性 有序性  JMM关于同步的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png">
<meta property="article:published_time" content="2023-04-02T03:16:46.000Z">
<meta property="article:modified_time" content="2023-05-08T12:20:55.486Z">
<meta property="article:author" content="小新">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png"><link rel="shortcut icon" href="http://qn.liuwqtech.top/008i3skNgy1gpw51zrippj305k05k74p.jpg"><link rel="canonical" href="https://liuwqtech.github.io/2023/04/02/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%AD%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小新","link":"链接: ","source":"来源: 小新's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-08 20:20:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="http://qn.liuwqtech.top/008i3skNgy1gpw4suzt6aj30u00u077g.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">41</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小新's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java面试题第二季</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-02T03:16:46.000Z" title="发表于 2023-04-02 11:16:46">2023-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-08T12:20:55.486Z" title="更新于 2023-05-08 20:20:55">2023-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java面试题第二季"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>volatile是Java虚拟机提供的<strong>轻量</strong>级的<strong>同步机制</strong>。</p>
<ul>
<li><strong>保证可见性</strong></li>
<li><strong>不保证原子性</strong></li>
<li><strong>禁止指令重排</strong></li>
</ul>
<h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2><p>JMM（Java内存模型Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。</p>
<ul>
<li>可见性</li>
<li>原子性</li>
<li>有序性</li>
</ul>
<p>JMM关于同步的规定：</p>
<ul>
<li>线程解锁前，必须把共享变量的值刷新回主内存</li>
<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>
<li>加锁解锁是同一把锁</li>
</ul>
<p>由于JVM运行程序的实体是线程，而每个线程创建时，JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而<strong>Java内存模型中规定所有变量都存储在主内存</strong>，主内存是共享内存区域，所有线程都可以访问，但<strong>线程对变量的操作（读取赋值）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7.png" style="zoom:67%;" />

<h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>原子性：不可分割、完整性，即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整，要么同时成功，要么同时失败。</p>
<p>代码示例：（数据操作丢失）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + myData.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ul>
<li><strong>加synchronized</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    number ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用JUC下的AtomicInteger</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number ++;</span><br><span class="line">    &#125;</span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                    myData.addAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;int type,result1:&quot;</span> + myData.number);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger type,result1:&quot;</span> + myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h2><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>计算机在执行程序时，为了提高性能，编译器和处理器常常会<strong>对指令做重排</strong>，一般分为以下三种：</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.png" style="zoom: 50%;" />

<p>单线程环境里面确保程序最终执行结果与代码顺序执行的结果一致。</p>
<p>处理器在进行重排序时必须考虑指令之间的<strong>数据依赖性</strong>。</p>
<p><strong>多线程环境中线程交替执行</strong>，由于编译器优化重排的存在，两个线程中使用的变量能都保证一致性是无法确定的，结果无法预测。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>volatile实现<strong>禁止指令重排优化</strong>，从而避免多线程环境下程序出现乱序执行的现象。</p>
<p>什么叫做内存屏障（Memory Barrier）？</p>
<p>又称内存栅栏，是一个cpu指令，它的作用有两个：</p>
<ul>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</li>
</ul>
<p>由于编译器和处理器都能执行指令重排优化。如果在指令期间插入一条Memory Barrier，则会告诉编译器和cpu，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说<strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong>。内存屏障另一个作用是强制刷出各种cpu的缓存数据，因此任何cpu上的线程都能读取到这些数据的最新版本。</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.png" style="zoom:67%;" />

<h2 id="线程安全性获得保证"><a href="#线程安全性获得保证" class="headerlink" title="线程安全性获得保证"></a>线程安全性获得保证</h2><p>工作内存和主内存同步延迟现象导致的可见性问题：</p>
<ul>
<li>使用synchronized或者volatile关键字解决，它们都可以<strong>使一个线程修改后的变量立即对其他线程可见</strong>。</li>
</ul>
<p>对于指令重排序导致的可见性和有序性问题：</p>
<ul>
<li>可以利用volatile关键字解决，因为它<strong>可以禁止指令重排序</strong>。</li>
</ul>
<h1 id="什么地方可以用volatile"><a href="#什么地方可以用volatile" class="headerlink" title="什么地方可以用volatile"></a>什么地方可以用volatile</h1><h2 id="多线程下会有安全问题"><a href="#多线程下会有安全问题" class="headerlink" title="多线程下会有安全问题"></a>多线程下会有安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 我是构造方法Singleton()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                Singleton.getInstance();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0	 我是构造方法Singleton()</span><br><span class="line">2	 我是构造方法Singleton()</span><br><span class="line">1	 我是构造方法Singleton()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="单例模式DCL"><a href="#单例模式DCL" class="headerlink" title="单例模式DCL"></a>单例模式DCL</h2><p>DCL（Double Check Lock，双端检锁机制）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式volatile分析"><a href="#单例模式volatile分析" class="headerlink" title="单例模式volatile分析"></a>单例模式volatile分析</h2><p>DCL（双端检锁）机制不一定线程安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排序。</p>
<p>原因在于某一个线程执行到第一次检测时，读取到的instance不为null，但instance的引用对象<strong>可能没有完成初始化</strong>。</p>
<p><code>instance = new Singleton();</code>可以分为以下3步完成（伪代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br><span class="line">instance = memory; <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance!=null</span></span><br></pre></td></tr></table></figure>

<p>步骤2和步骤3<strong>不存在数据依赖关系</strong>，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排序优化是允许的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance = memory; <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance!=null ，！！！但是对象还没有初始化完成</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br></pre></td></tr></table></figure>

<p>指令重排只会保证串行语义的执行的一致性，并不会关心多线程之间的语义一致性。</p>
<p><strong>所以当一条线程访问instance不为null时，由于instance实例未必已经初始化完成，所以会有线程安全问题。</strong></p>
<p>解决：加入volatile关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS-Demo"><a href="#CAS-Demo" class="headerlink" title="CAS Demo"></a>CAS Demo</h2><p>CompareAndSwap，<strong>比较并交换</strong>。</p>
<p><strong>与期望值相同，才可以进行修改</strong>，返回布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2023</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1029</span>) + <span class="string">&quot;\t current data: &quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true	 current data: 2023</span><br><span class="line">false	 current data: 2023</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<strong>Unsafe类存在于sun.misc包中</strong>，其内部方法操作可以向C的指针一样直接操作内存，因为Java中的CAS操作的执行依赖于Unsafe类的方法。</p>
<p>注意：<strong>Unsafe类中所有的方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。</strong></p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/Unsafe%E6%BA%90%E7%A0%81.png" style="zoom:50%;" />

<p>变量valueOffset，表示<strong>该变量在内存中的偏移地址</strong>，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<p>变量value用volatile修饰，保证了多线程之间的内存可见性。</p>
<h3 id="CAS-1"><a href="#CAS-1" class="headerlink" title="CAS"></a>CAS</h3><p>CAS，全称Compare-And-Swap，是<strong>一条CPU并发原语</strong>。</p>
<p>功能：判断内存某个位置的值是否为预期值，如果是，则更改为新的值，<strong>这个过程是原子的</strong>。</p>
<p>CAS并发原语体现在Java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且<strong>原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</strong></p>
<p><code>atomicInteger.getAndIncrement()</code>源码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>o</code>：AtomicInteger对象本身</li>
<li><code>offset</code>：该对象值的引用地址</li>
<li><code>delta</code>：需要变动的数量</li>
<li><code>v</code>：通过<code>o</code>和<code>offset</code>找出的主内存中真实的值</li>
</ul>
<p>用该对象当前的值与v进行比较：</p>
<ul>
<li>相同：更新<code>v + delta</code>并返回true</li>
<li>不同：继续取值，然后再比较，知道更新完成</li>
</ul>
<p>过程示例：</p>
<p>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同的CPU上）</p>
<ol>
<li>AtomicInteger里面的value原始值为5，即主内存中AtomicInteger的value为5，根据JMM模型，线程A和线程B各自持有一份值为5的value的副本到各自的工作内存中。</li>
<li>线程A通过<code>getIntVolatile(o, offset)</code>方法，拿到value值5，这时线程A被挂起。</li>
<li>此时线程B也通过<code>getIntVolatile(o, offset)</code>方法，拿到value值5，此时刚好线程B<strong>没有被挂起，并执行</strong><code>compareAndSwapInt(o, offset, v, v + delta)</code>方法比较内存值也为5，成功修改内存值为6，线程B打完收工，一切OK。</li>
<li>这时线程A恢复，执行<code>compareAndSwapInt(o, offset, v, v + delta)</code>方法比较，发现自己手里的值5和主内存值6不一致，说明该值已经被其他线程抢先一步修改过了，<strong>那A线程本次修改失败，智能重新读取重新再来一遍</strong>。</li>
<li>线程A重新获取value值，因为变量value被volatile修饰，满足可见性，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行<code>compareAndSwapInt(o, offset, v, v + delta)</code>进行比较替换，直到成功。</li>
</ol>
<h2 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h2><ol>
<li><strong>循环时间长，开销大</strong><ul>
<li>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong><ul>
<li>对多个共享变量，只能通过加锁来保证原子性</li>
</ul>
</li>
<li><strong>引出ABA问题</strong></li>
</ol>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><h3 id="如何引发"><a href="#如何引发" class="headerlink" title="如何引发"></a>如何引发</h3><p><strong>狸猫换太子～</strong></p>
<p>CAS会导致“ABA问题”。CAS算法实现一个重要前提需要取出内存中某时刻的数据，并在当下时刻进行比较并替换，那么在这个时间差里可能会导致数据的变化。</p>
<p>比如说，一个线程T1从内存位置V中取出A，这时候另一个线程T2也从内存中取出A，并且线程T2进行了一些操作将值变为了B，然后线程T2又将V位置的数据变成A，这时候线程T1进行CAS操作发现内存中仍然是A，然后T1操作成功。<strong>尽管T1线程CAS操作成功，但并不代表这个过程就是没有问题的。</strong></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User lisi = <span class="keyword">new</span> User(<span class="string">&quot;lisi&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(zhangsan);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(zhangsan, lisi) + <span class="string">&quot;\t&quot;</span> + atomicReference.get().toString());</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(zhangsan, lisi) + <span class="string">&quot;\t&quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间戳原子引用"><a href="#时间戳原子引用" class="headerlink" title="时间戳原子引用"></a>时间戳原子引用</h4><p>新增一种机制，那就是<strong>修改版本号（类似于时间戳）</strong>——AtomicStampedReference</p>
<p><strong>ABA问题演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========以下是ABA问题的产生========&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//暂停1秒钟，保证上面T1线程完成了一次ABA操作</span></span><br><span class="line">            <span class="keyword">try</span>&#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125;<span class="keyword">catch</span> (InterruptedException e)&#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">&quot;\t&quot;</span> + atomicReference.get());</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">========以下是ABA问题的产生========</span><br><span class="line">true	2019</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>ABA问题的解决：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;========以下是ABA问题的解决========&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">//暂停1秒钟T3线程</span></span><br><span class="line">            <span class="keyword">try</span>&#123;TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第2次版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第3次版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;T3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t第1次版本号：&quot;</span> + stamp);</span><br><span class="line">            <span class="comment">//暂停3秒钟T4线程</span></span><br><span class="line">            <span class="keyword">try</span>&#123;TimeUnit.SECONDS.sleep(<span class="number">3</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2023</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t修改成功否：&quot;</span> + result + <span class="string">&quot;\t当前最新实际版本号：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t当前实际最新值：&quot;</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;T4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">========以下是ABA问题的解决========</span><br><span class="line">T3	第1次版本号：1</span><br><span class="line">T4	第1次版本号：1</span><br><span class="line">T3	第2次版本号：2</span><br><span class="line">T3	第3次版本号：3</span><br><span class="line">T4	修改成功否：false	当前最新实际版本号：3</span><br><span class="line">T4	当前实际最新值：100</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h1><h2 id="ArrayList线程安全问题"><a href="#ArrayList线程安全问题" class="headerlink" title="ArrayList线程安全问题"></a>ArrayList线程安全问题</h2><h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerNotSafeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><p><strong>java.util.ConcurrentModificationException</strong></p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/ArrayList%E5%B9%B6%E5%8F%91%E5%BC%82%E5%B8%B8.png" style="zoom: 50%;" />

<h3 id="导致原因"><a href="#导致原因" class="headerlink" title="导致原因"></a>导致原因</h3><p>并发争抢修改导致，参考花名册签名情况（一个人正在写入，另一个人过来争抢，导致数据不一致异常）</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写时复制：</strong></p>
<p>CopyOnWrite容器，即写时复制容器。往一个容器添加元素的时候，不直接往当前容器<code>Object[]</code>添加，而是先将当前容器<code>Object[]</code>进行copy，复制出一个新的容器<code>Object[] newElements</code>，然后新的容器<code>Object[] newElements</code>里添加元素，添加完元素之后，再将原容器的引用指向新的容器<code>setArray(newElements)</code>。</p>
<p>这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h2 id="Set线程安全问题"><a href="#Set线程安全问题" class="headerlink" title="Set线程安全问题"></a>Set线程安全问题</h2><h3 id="故障现象-1"><a href="#故障现象-1" class="headerlink" title="故障现象"></a>故障现象</h3><p><strong>java.util.ConcurrentModificationException</strong></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="Collections-1"><a href="#Collections-1" class="headerlink" title="Collections"></a>Collections</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>补充：HashSet底层就是HashMap，至于为什么map有key和value两个值，而set只有一个，是因为调用HashSet调用add方法，实际上返回一个map，只不过添加进的数据是map里的key，value是一个固定的常量。</strong></p>
<h2 id="Map线程安全问题"><a href="#Map线程安全问题" class="headerlink" title="Map线程安全问题"></a>Map线程安全问题</h2><h3 id="故障现象-2"><a href="#故障现象-2" class="headerlink" title="故障现象"></a>故障现象</h3><p><strong>java.util.ConcurrentModificationException</strong></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="Collections-2"><a href="#Collections-2" class="headerlink" title="Collections"></a>Collections</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过构造函数指定该锁是否是公平锁，默认非公平锁。</strong></p>
<p>公平锁是什么？——是指<strong>多个线程按照申请锁的顺序来获取锁</strong>，类似于排队打饭，先来后到。</p>
<p>非公平锁是什么？——是指<strong>多个线程获取锁的顺序并不是按照申请锁的顺序</strong>，有可能后申请的线程比先申请的线程优先获取锁。在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>公平锁，就是很公平，在并发环境下，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</li>
<li>非公平锁，比较粗鲁，上来就直接占有锁，如果尝试失败，就在采用类似公平锁的那种方式。</li>
<li><strong>非公平锁的优点在于吞吐量比公平锁大，synchronized就是一种非公平锁</strong>。</li>
</ul>
<h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>可重入锁，也叫递归锁。指的是同一线程外层函数获得锁之后，内层递归函数仍能获取到该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p>也就是说，<strong>线程可以进入到任何一个它已经拥有的锁所同步着的代码块</strong>。</p>
<p><strong>ReentrantLock/Synchronized就是典型的可重入锁。</strong></p>
<p><strong>可重入锁最大的作用：可以避免死锁。</strong></p>
<h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><ul>
<li>Synchronized是一个典型的可重入锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked sendSMS()&quot;</span>);</span><br><span class="line">        sendEmail();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ###### invoked sendEmail()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendSMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1	 invoked sendSMS()</span><br><span class="line">T1	 ###### invoked sendEmail()</span><br><span class="line">T2	 invoked sendSMS()</span><br><span class="line">T2	 ###### invoked sendEmail()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<ul>
<li>ReentrantLock是一个典型的可重入锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoked get()&quot;</span>);</span><br><span class="line">            set();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t ###### invoked set()&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(phone);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(phone);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread-0	 invoked get()</span><br><span class="line">Thread-0	 ###### invoked set()</span><br><span class="line">Thread-1	 invoked get()</span><br><span class="line">Thread-1	 ###### invoked set()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p><strong>注意：加双锁可不可以，编译能通过吗？能运行成功吗？</strong></p>
<ul>
<li><strong>可以，能编译成功且运行成功，但加锁解锁要对应。</strong></li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>自旋锁，spinlock，是指<strong>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁</strong>，这样的<strong>好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</strong>。</p>
<p>CAS——自旋锁</p>
<p>循环比较获取直到成功为止，没有类似wait的阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码验证-1"><a href="#代码验证-1" class="headerlink" title="代码验证"></a>代码验证</h3><p>通过CAS操作完成自旋锁，A线程先进来调用MyLock方法自己持有锁5秒钟，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B抢到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//原子引用线程</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t come in ~&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t invoke MyUnLock()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpinLockDemo spinLockDemo = <span class="keyword">new</span> SpinLockDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.MyLock();</span><br><span class="line">            <span class="comment">//暂停一会儿</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">            spinLockDemo.MyUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.MyLock();</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;</span><br><span class="line">            spinLockDemo.MyUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1	 come in ~</span><br><span class="line">T2	 come in ~</span><br><span class="line">T1	 invoke MyUnLock()</span><br><span class="line">T2	 invoke MyUnLock()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="独占锁（写锁）-共享锁（读锁）-互斥锁"><a href="#独占锁（写锁）-共享锁（读锁）-互斥锁" class="headerlink" title="独占锁（写锁）/共享锁（读锁）/互斥锁"></a>独占锁（写锁）/共享锁（读锁）/互斥锁</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><ul>
<li>独占锁：指该锁一次只能被一个线程所持有。<strong>ReentrantLock和Synchronized都是独占锁。</strong></li>
<li>共享锁：指该锁可被多个线程所持有。</li>
</ul>
<p><strong>ReentrantReadWriteLock，其读锁是共享锁，写锁是独占锁。</strong></p>
<p>读锁的共享锁可保证并发读是非常高效的，读写/写读/写写的过程是互斥的。</p>
<p>多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是，如果有一个线程想去写共享资源表，就不应该再有其他线程可以对该资源进行读或者写。</p>
<p>小总结：</p>
<ul>
<li>读-读：可共存</li>
<li>读-写：不可共存</li>
<li>写-写：不可共存</li>
</ul>
<h3 id="代码验证-2"><a href="#代码验证-2" class="headerlink" title="代码验证"></a>代码验证</h3><h4 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">        <span class="comment">//模拟网络拥堵</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟网络拥堵</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        Object value = map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(tempInt+<span class="string">&quot;&quot;</span>,tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1	 正在写入：1</span><br><span class="line">3	 正在写入：3</span><br><span class="line">2	 正在写入：2</span><br><span class="line">5	 正在写入：5</span><br><span class="line">4	 正在写入：4</span><br><span class="line">1	 正在读取</span><br><span class="line">2	 正在读取</span><br><span class="line">3	 正在读取</span><br><span class="line">4	 正在读取</span><br><span class="line">5	 正在读取</span><br><span class="line">1	 写入完成</span><br><span class="line">4	 读取完成：4</span><br><span class="line">4	 写入完成</span><br><span class="line">3	 读取完成：3</span><br><span class="line">3	 写入完成</span><br><span class="line">2	 写入完成</span><br><span class="line">5	 写入完成</span><br><span class="line">2	 读取完成：2</span><br><span class="line">1	 读取完成：1</span><br><span class="line">5	 读取完成：5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>显然，写操作被打断的一塌糊涂～</p>
<h4 id="After"><a href="#After" class="headerlink" title="After"></a>After</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在写入：&quot;</span> + key);</span><br><span class="line">            <span class="comment">//模拟网络拥堵</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 正在读取&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟网络拥堵</span></span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            Object value = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 读取完成：&quot;</span> + value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(tempInt+<span class="string">&quot;&quot;</span>,tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(tempInt+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1	 正在写入：1</span><br><span class="line">1	 写入完成</span><br><span class="line">2	 正在写入：2</span><br><span class="line">2	 写入完成</span><br><span class="line">4	 正在写入：4</span><br><span class="line">4	 写入完成</span><br><span class="line">3	 正在写入：3</span><br><span class="line">3	 写入完成</span><br><span class="line">5	 正在写入：5</span><br><span class="line">5	 写入完成</span><br><span class="line">1	 正在读取</span><br><span class="line">2	 正在读取</span><br><span class="line">3	 正在读取</span><br><span class="line">4	 正在读取</span><br><span class="line">5	 正在读取</span><br><span class="line">3	 读取完成：3</span><br><span class="line">4	 读取完成：4</span><br><span class="line">1	 读取完成：1</span><br><span class="line">2	 读取完成：2</span><br><span class="line">5	 读取完成：5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="JUC其他类"><a href="#JUC其他类" class="headerlink" title="JUC其他类"></a>JUC其他类</h1><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="情景复现"><a href="#情景复现" class="headerlink" title="情景复现"></a>情景复现</h3><p>我们期望所有人走后，班长再关门离开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t上完自习，离开教室&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t###### 班长关门，走人 ######&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	上完自习，离开教室</span><br><span class="line">4	上完自习，离开教室</span><br><span class="line">3	上完自习，离开教室</span><br><span class="line">main	###### 班长关门，走人 ######</span><br><span class="line">2	上完自习，离开教室</span><br><span class="line">6	上完自习，离开教室</span><br><span class="line">5	上完自习，离开教室</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t上完自习，离开教室&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t###### 班长关门，走人 ######&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1	上完自习，离开教室</span><br><span class="line">5	上完自习，离开教室</span><br><span class="line">4	上完自习，离开教室</span><br><span class="line">3	上完自习，离开教室</span><br><span class="line">2	上完自习，离开教室</span><br><span class="line">6	上完自习，离开教室</span><br><span class="line">main	###### 班长关门，走人 ######</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>采用枚举，限制线程名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CountryEnum</span> </span>&#123;</span><br><span class="line">    ONE(<span class="number">1</span>,<span class="string">&quot;齐&quot;</span>),</span><br><span class="line">    TWO(<span class="number">2</span>,<span class="string">&quot;楚&quot;</span>),</span><br><span class="line">    THREE(<span class="number">3</span>,<span class="string">&quot;燕&quot;</span>),</span><br><span class="line">    FOUR(<span class="number">4</span>,<span class="string">&quot;赵&quot;</span>),</span><br><span class="line">    FIVE(<span class="number">5</span>,<span class="string">&quot;魏&quot;</span>),</span><br><span class="line">    SIX(<span class="number">6</span>,<span class="string">&quot;韩&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer Code;</span><br><span class="line">    <span class="keyword">private</span> String Message;</span><br><span class="line"></span><br><span class="line">    CountryEnum(Integer code, String message) &#123;</span><br><span class="line">        Code = code;</span><br><span class="line">        Message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CountryEnum <span class="title">forEach_CountryEnum</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        CountryEnum[] values = CountryEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (CountryEnum element : values)&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == element.getCode())&#123;</span><br><span class="line">                <span class="keyword">return</span> element;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;国，被灭&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,CountryEnum.forEach_CountryEnum(i).getMessage()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t秦帝国，一统天下&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">齐国，被灭</span><br><span class="line">燕国，被灭</span><br><span class="line">楚国，被灭</span><br><span class="line">赵国，被灭</span><br><span class="line">魏国，被灭</span><br><span class="line">韩国，被灭</span><br><span class="line">main	秦帝国，一统天下</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CountDownLatch：<strong>让一些线程阻塞，直到另一些线程完成一系列操作后才被唤醒。</strong></p>
<p>CountDownLatch主要有两个方法：</p>
<ul>
<li>当一个或者多个线程调用await方法时，调用线程会被阻塞。</li>
<li>其他线程调用countDown方法时，会将计数器减1（调用countDown方法的线程不会阻塞），当计数器的值为0时，调用await方法的线程才会被唤醒，继续执行。</li>
</ul>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>CyclicBarrier字面意思是可循环使用的屏障。它要做的事情是：让一组线程到达一个屏障（也可以叫做同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。</p>
<h3 id="代码验证-3"><a href="#代码验证-3" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******召唤神龙******&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 收集到第：&quot;</span> + tempInt + <span class="string">&quot;龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1	 收集到第：1龙珠</span><br><span class="line">4	 收集到第：4龙珠</span><br><span class="line">5	 收集到第：5龙珠</span><br><span class="line">6	 收集到第：6龙珠</span><br><span class="line">7	 收集到第：7龙珠</span><br><span class="line">3	 收集到第：3龙珠</span><br><span class="line">2	 收集到第：2龙珠</span><br><span class="line">******召唤神龙******</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><p>信号量：主要用于两个目的</p>
<ul>
<li>一个是用于多个共享资源的互斥使用</li>
<li>一个用于并发线程数的控制</li>
</ul>
<h3 id="代码验证-4"><a href="#代码验证-4" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>); <span class="comment">//模拟三个停车位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123; <span class="comment">//模拟6辆汽车</span></span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t停车3秒后离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1	抢到车位</span><br><span class="line">3	抢到车位</span><br><span class="line">2	抢到车位</span><br><span class="line">1	停车3秒后离开车位</span><br><span class="line">2	停车3秒后离开车位</span><br><span class="line">4	抢到车位</span><br><span class="line">3	停车3秒后离开车位</span><br><span class="line">5	抢到车位</span><br><span class="line">6	抢到车位</span><br><span class="line">6	停车3秒后离开车位</span><br><span class="line">4	停车3秒后离开车位</span><br><span class="line">5	停车3秒后离开车位</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="是什么-6"><a href="#是什么-6" class="headerlink" title="是什么"></a>是什么</h2><p>顾名思义，首先，它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下图所示：</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" style="zoom:50%;" />

<p>线程1往阻塞队列中添加元素，线程2从阻塞队列中移除元素。</p>
<ul>
<li>当阻塞队列是<strong>空</strong>时，从队列中<strong>获取</strong>元素的操作将会被阻塞。</li>
<li>当阻塞队列是<strong>满</strong>时，从队列中<strong>添加</strong>元素的操作将会被阻塞。</li>
</ul>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会被自动唤醒。</p>
<p>为什么需要BlockingQueue？</p>
<ul>
<li><strong>不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程</strong></li>
</ul>
<p>在concurrent包发布以前，在多线程环境下，我们每个程序猿都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这样会给我们的程序带来不小的复杂度。</p>
<h2 id="架构梳理-种类分析"><a href="#架构梳理-种类分析" class="headerlink" title="架构梳理+种类分析"></a>架构梳理+种类分析</h2><p><strong>List和BlockingQueue属于平级，都是Collection接口下的子接口～</strong></p>
<ul>
<li><code>ArrayBlockingQueue</code>：<strong>由数组结构组成的有界阻塞队列</strong></li>
<li><code>LinkedBlockingQueue</code>：<strong>由链表结构组成的有界（但大小默认<code>Integer.MAX_VALUE</code>）阻塞队列</strong></li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列</li>
<li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列</li>
<li><code>SynchronousQueue</code>：<strong>不存储元素的阻塞队列，也即单个元素的队列</strong></li>
<li><code>LinkedTransferQueue</code>：由链表结构组成的无界阻塞队列</li>
<li><code>LinkedBlockingDeque</code>：由链表结构组成的双向阻塞队列</li>
</ul>
<h2 id="阻塞队列api"><a href="#阻塞队列api" class="headerlink" title="阻塞队列api"></a>阻塞队列api</h2><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%8A%9B%E5%BC%82%E5%B8%B8.png" style="zoom:50%;" />

<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97api.png" style="zoom:50%;" />

<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><h3 id="是什么-7"><a href="#是什么-7" class="headerlink" title="是什么"></a>是什么</h3><p>SynchronousQueue没有容量。</p>
<p>与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。</p>
<p><strong>每一个put操作必须要等待一个take操作，否则不能添加元素，反之亦然。</strong></p>
<h3 id="代码验证-5"><a href="#代码验证-5" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take&quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t take&quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T1	 put 1</span><br><span class="line">T2	 take1</span><br><span class="line">T1	 put 2</span><br><span class="line">T2	 take2</span><br><span class="line">T1	 put 3</span><br><span class="line">T2	 take3</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="用在哪里"><a href="#用在哪里" class="headerlink" title="用在哪里"></a>用在哪里</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><h4 id="传统版"><a href="#传统版" class="headerlink" title="传统版"></a>传统版</h4><p>一个初始值为0的变量，两个线程对其进行交替操作，一个加1一个减1，来5轮</p>
<ol>
<li>线程 操作 资源类</li>
<li>判断 干活 通知</li>
<li>防止虚假唤醒</li>
</ol>
<p><strong>线程的判断，必须放到while循环中，不能用if</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-08 09:29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一个初始值为0的变量，两个线程对其进行交替操作，一个加1一个减1，来5轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待，不能生产</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">// 3、唤醒</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待，不能消费</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2、干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">            <span class="comment">// 3、唤醒</span></span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_TraditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.increase();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    shareData.reduce();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">T1	1</span><br><span class="line">T2	0</span><br><span class="line">T1	1</span><br><span class="line">T2	0</span><br><span class="line">T1	1</span><br><span class="line">T2	0</span><br><span class="line">T1	1</span><br><span class="line">T2	0</span><br><span class="line">T1	1</span><br><span class="line">T2	0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h4 id="阻塞队列版"><a href="#阻塞队列版" class="headerlink" title="阻塞队列版"></a>阻塞队列版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-08 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">//默认开启，进行生产+消费</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyResource</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        System.out.println(blockingQueue.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyProd</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> retValue = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            data = atomicInteger.incrementAndGet() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            blockingQueue.offer(data,<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (retValue)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列&quot;</span> + data + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 插入队列&quot;</span> + data + <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 大老板叫停，flag=false，生产动作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            result = blockingQueue.poll(<span class="number">2L</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.equalsIgnoreCase(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 超过2s没有取到蛋糕，消费退出&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费队列蛋糕&quot;</span> + result + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer_BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyResource myResource = <span class="keyword">new</span> MyResource(<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 生产线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.MyProd();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Prod&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 消费线程启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                myResource.MyConsumer();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;5s钟时间到，大老板main线程叫停，活动结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        myResource.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ArrayBlockingQueue</span><br><span class="line">Prod	 生产线程启动</span><br><span class="line">Consumer	 消费线程启动</span><br><span class="line">Prod	 插入队列1成功</span><br><span class="line">Consumer	 消费队列蛋糕1成功</span><br><span class="line">Prod	 插入队列2成功</span><br><span class="line">Consumer	 消费队列蛋糕2成功</span><br><span class="line">Prod	 插入队列3成功</span><br><span class="line">Consumer	 消费队列蛋糕3成功</span><br><span class="line">Prod	 插入队列4成功</span><br><span class="line">Consumer	 消费队列蛋糕4成功</span><br><span class="line">Prod	 插入队列5成功</span><br><span class="line">Consumer	 消费队列蛋糕5成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5s钟时间到，大老板main线程叫停，活动结束</span><br><span class="line">Prod	 大老板叫停，flag=false，生产动作结束</span><br><span class="line">Consumer	 超过2s没有取到蛋糕，消费退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h2><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ol>
<li>原始构成<ul>
<li>Synchronized是<strong>关键字，属于JVM层面</strong><ul>
<li><code>monitorenter</code>（<strong>底层通过monitor对象来完成</strong>，其实wait/notify等方法也依赖于monitor对象，只有在同步块或者方法中采用调用wait/notify等方法）</li>
<li><code>monitorexit</code></li>
</ul>
</li>
<li>Lock是<strong>具体类</strong>（java.util.concurrent.locks.lock），<strong>是api层面的锁</strong></li>
</ul>
</li>
<li>使用方法<ul>
<li>Synchronized<strong>不需要用户去手动释放锁</strong>，当Synchronized代码执行完后，系统会自动让线程释放对锁的占用</li>
<li>ReentrantLock<strong>则需要用户手动释放锁</strong>，若没有主动释放，就有可能导致死锁现象，需要<code>lock()</code>和<code>unlock()</code>方法配合try/finally语句块来完成</li>
</ul>
</li>
<li>等待是否可中断<ul>
<li>Synchronized<strong>不可中断</strong>，除非抛出异常或者正常运行完成</li>
<li>ReentrantLock<strong>可以中断</strong><ul>
<li>设置超时方法<code>tryLock(long timeout, TimeUnit unit)</code></li>
<li><code>lockInterruptibly()</code>放代码块中，调用<code>interrupt()</code>方法可以中断</li>
</ul>
</li>
</ul>
</li>
<li>加锁是否公平<ul>
<li>Synchronized<strong>非公平锁</strong></li>
<li>ReentrantLock<strong>两者都可以</strong>，默认非公平锁，构造方法可以传入boolean值，true为公平锁，false为非公平锁</li>
</ul>
</li>
<li>锁绑定多个条件<ul>
<li>Synchronized<strong>没有</strong></li>
<li>ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以<strong>精确唤醒</strong>，而不是像Synchronized要么随机唤醒一个线程要么唤醒全部线程</li>
</ul>
</li>
</ol>
<h3 id="Lock好处-锁绑定多个条件Condition"><a href="#Lock好处-锁绑定多个条件Condition" class="headerlink" title="Lock好处: 锁绑定多个条件Condition"></a>Lock好处: 锁绑定多个条件Condition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-08 10:16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 多线程之间按顺序调用，实现A-&gt;B-&gt;C三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * A打印5次，B打印10次，C打印15次</span></span><br><span class="line"><span class="comment"> * ······</span></span><br><span class="line"><span class="comment"> * 来10轮</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2、干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncAndReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareResource shareResource = <span class="keyword">new</span> ShareResource();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                shareResource.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><p>获取线程的另外一种方式，支持线程返回值。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>线程池做的工作主要是控制运行的线程的数量，<strong>处理过程中将任务放入队列</strong>，然后在线程创建后启动这些任务，<strong>如果线程数量超过了最大数量，超出数量的线程排队等候</strong>，等其他线程执行完毕后，再从队列中取出任务来执行。</p>
<p>主要特点：</p>
<ul>
<li>线程复用</li>
<li>控制最大并发数</li>
<li>管理线程</li>
</ul>
<ol>
<li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<h2 id="线程池3个常用方式"><a href="#线程池3个常用方式" class="headerlink" title="线程池3个常用方式"></a>线程池3个常用方式</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor、Executors、ExecutorService、<strong>ThredPoolExecutor</strong>这几个类。</p>
<h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ol>
<li><code>Executors.newScheduledThreadPool()</code>：带调度的</li>
<li>Java8新出：<code>Executors.newWorkStealingPool(int)</code>——Java8，使用目前机器上可用的处理器作为它的并行级别</li>
</ol>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><h4 id="Executors-newFixedThreadPool-int"><a href="#Executors-newFixedThreadPool-int" class="headerlink" title="Executors.newFixedThreadPool(int)"></a>Executors.newFixedThreadPool(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点如下：</p>
<ul>
<li><strong>执行长期的任务，性能好很多</strong></li>
<li>创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待</li>
<li>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue</li>
</ul>
<h4 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点如下：</p>
<ul>
<li><strong>一个任务一个任务执行的场景</strong></li>
<li>创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序执</li>
<li>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，使用LinkedBlockingQueue</li>
</ul>
<h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要特点如下：</p>
<ul>
<li><strong>适用：执行很多短期异步的小程序或者负载较轻的服务器</strong></li>
<li>创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li>
<li>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用SynchronousQueue，也就说，来了任务就创建线程运行，当线程空闲超过60s，就销毁线程。</li>
</ul>
<h2 id="线程池7大参数"><a href="#线程池7大参数" class="headerlink" title="线程池7大参数"></a>线程池7大参数</h2><h3 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h3><p>线程池中的<strong>常驻核心线程数</strong></p>
<ul>
<li>在创建了线程池后，当有请求任务来后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程</li>
<li>当线程池中的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中</li>
</ul>
<h3 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h3><p>线程池能够容纳<strong>同时执行的最大线程数</strong>，此值必须大于等于1</p>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p><strong>多余的空闲线程的存活时间</strong>。当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止</p>
<h3 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h3><p>keepAliveTime的单位</p>
<h3 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h3><p>任务队列，<strong>被提交但尚未被执行的任务</strong></p>
<h3 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h3><p>表示生成线程池中工作线程的线程工厂，用于<strong>创建线程</strong>，<strong>一般用默认的即可</strong></p>
<h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数maximumPoolSize，就拒绝任务</p>
<h2 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h2><p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<ol>
<li>在创建了线程池后，等待提交过来的任务请求</li>
<li>当调用<code>execute()</code>方法，添加一个请求任务时，线程池会做以下判断：<ol>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li>
<li>如果正在运行的线程数量大于等于corePoolSize，那么将这个任务<strong>放入队列</strong></li>
<li>如果队列满了，且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务</li>
<li>如果队列满了，且正在运行的线程数量大于等于maximumPoolSize，那么线程池会<strong>启动饱和拒绝策略</strong></li>
</ol>
</li>
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行</li>
<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会做以下判断：<ol>
<li>如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉</li>
<li>所有线程池的任务都完成后，会<strong>最终收缩到corePoolSize大小</strong></li>
</ol>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><h3 id="是什么-8"><a href="#是什么-8" class="headerlink" title="是什么"></a>是什么</h3><p><strong>等待队列满了</strong>，再也塞不下新任务了，同时，<strong>线程池中的max线程也达到了</strong>，无法继续为新任务服务。</p>
<p>这个时候线程池就会采用一定的拒绝策略合理地处理这个问题。</p>
<h3 id="JDK内置的拒绝策略"><a href="#JDK内置的拒绝策略" class="headerlink" title="JDK内置的拒绝策略"></a>JDK内置的拒绝策略</h3><ul>
<li>AbortPolicy（默认）：直接抛出RejectedExecutionException<strong>异常</strong>组织系统正常运行</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务<strong>回退到调用者</strong>，从而降低新的任务流量</li>
<li>DiscardOldestPolicy：<strong>抛弃队列中等待最久的任务</strong>，然后把当前任务加入队列中尝试再次提交当前任务</li>
<li>DiscardPolicy：<strong>直接丢弃任务</strong>，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案</li>
</ul>
<p>以上内置拒绝策略均实现了RejectedExecutionHandler接口</p>
<h2 id="工作中用哪个？"><a href="#工作中用哪个？" class="headerlink" title="工作中用哪个？"></a>工作中用哪个？</h2><p><strong>！！！！一个也不用，生产上我们只用自定义的。</strong></p>
<p>因为不管是固定数量的、单一的还是有缓存的线程池，里面用到的阻塞队列都是无界的，2亿多呢。。。</p>
<h2 id="线程池手写改造和拒绝策略"><a href="#线程池手写改造和拒绝策略" class="headerlink" title="线程池手写改造和拒绝策略"></a>线程池手写改造和拒绝策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-09 21:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">1L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池合理配置线程数"><a href="#线程池合理配置线程数" class="headerlink" title="线程池合理配置线程数"></a>线程池合理配置线程数</h2><h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>CPU密集的意思是：该任务需要大量的运算，而且没有阻塞，CPU一直全速运行</p>
<p>CPU密集任务只有在真正的多核CPU上才可能得到加速（通过多线程），而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总运算能力就那些。</p>
<p><strong>CPU密集型任务：配置尽可能少的线程数量（一般公式：CPU核数+1个线程的线程池）</strong></p>
<h3 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h3><ol>
<li>由于IO密集型任务线程并不是一直在执行任务，所以应配置尽可能多的线程，例如：CPU核数*2</li>
<li>IO密集型，即该任务需要大量IO，即大量阻塞。在单线程上运行IO密集型任务会导致浪费大量的CPU运算能力（等待），所以在IO密集型任务中使用多线程可以大大加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。</li>
</ol>
<p><strong>IO密集型时，大部分线程都阻塞，所以应该配置多个线程数：</strong></p>
<p><strong>参考公式：CPU核数/（1-阻塞系数） 阻塞系数在0.8-0.9之间</strong></p>
<h1 id="死锁编码分析及定位分析"><a href="#死锁编码分析及定位分析" class="headerlink" title="死锁编码分析及定位分析"></a>死锁编码分析及定位分析</h1><h2 id="是什么-9"><a href="#是什么-9" class="headerlink" title="是什么"></a>是什么</h2><p>死锁是指两个或两个以上的进程在执行过程中，<strong>因争夺资源而造成的一种互相等待的现象</strong>，若<strong>无外力干涉那他们都将无法推进下去</strong>，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89.png" style="zoom:50%;" />

<h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><ul>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-10 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldLockThread</span><span class="params">(String lockA, String lockB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockA = lockA;</span><br><span class="line">        <span class="keyword">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有：&quot;</span> + lockA + <span class="string">&quot;\t 尝试获得：&quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;TimeUnit.SECONDS.sleep(<span class="number">2</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 自己持有：&quot;</span> + lockB + <span class="string">&quot;\t 尝试获得：&quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB = <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockA,lockB),<span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldLockThread(lockB,lockA),<span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%AD%BB%E9%94%81%E7%8E%B0%E8%B1%A1.png" style="zoom:50%;" />

<h2 id="定位分析"><a href="#定位分析" class="headerlink" title="定位分析"></a>定位分析</h2><h3 id="jps-l"><a href="#jps-l" class="headerlink" title="jps -l"></a>jps -l</h3><p>定位进程号</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/jps-l.png" style="zoom:50%;" />

<h3 id="jstack-进程号"><a href="#jstack-进程号" class="headerlink" title="jstack 进程号"></a>jstack 进程号</h3><p>找到死锁查看</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/jstack.png" style="zoom:50%;" />

<h1 id="JVM-GC回顾"><a href="#JVM-GC回顾" class="headerlink" title="JVM/GC回顾"></a>JVM/GC回顾</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="JVM体系概述"><a href="#JVM体系概述" class="headerlink" title="JVM体系概述"></a>JVM体系概述</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/JVM.png" style="zoom:50%;" />

<h3 id="Java8以后的JVM"><a href="#Java8以后的JVM" class="headerlink" title="Java8以后的JVM"></a>Java8以后的JVM</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/Java8%E4%BB%A5%E5%90%8E%E7%9A%84JVM.png" style="zoom:50%;" />

<h2 id="GC的作用域"><a href="#GC的作用域" class="headerlink" title="GC的作用域"></a>GC的作用域</h2><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/GC%E4%BD%9C%E7%94%A8%E5%9F%9F.png" style="zoom:50%;" />

<h2 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/1%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png" style="zoom:50%;" />

<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Java堆从GC的角度还可以细分为：</p>
<ul>
<li>新生代（Eden区、From Survivor区和To Survivor区）</li>
<li>老年代</li>
</ul>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/2%E5%A4%8D%E5%88%B6.png" style="zoom:50%;" />

<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/3%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" style="zoom:50%;" />

<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/4%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" style="zoom:50%;" />

<h1 id="JVM-GC面试题"><a href="#JVM-GC面试题" class="headerlink" title="JVM/GC面试题"></a>JVM/GC面试题</h1><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p><strong>题目：JVM垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots？</strong></p>
<p>什么是垃圾？——简单来说就是内存中已经不再被使用到的空间就是垃圾</p>
<p>要进行垃圾回收，如何判断一个对象是否可以被回收？</p>
<p><strong>枚举根节点做可达性分析（根搜索路径）</strong></p>
<p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。</p>
<p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%A0%B9%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84.png"></p>
<p>所谓“GC Roots”或者说tracing GC的“根集合”，<strong>就是一组必须活跃的引用</strong>。</p>
<p>基本思路：通过一系列名为“GC Roots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有遍历到的就自然被判定为死亡。</p>
<p><strong>Java中哪些可以作为GC Roots的对象</strong></p>
<ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM的参数类型"><a href="#JVM的参数类型" class="headerlink" title="JVM的参数类型"></a>JVM的参数类型</h3><h4 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h4><ul>
<li>-version</li>
<li>-help</li>
<li>java -showversion</li>
</ul>
<h4 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h4><ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式</li>
</ul>
<h4 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h4><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>公式：</p>
<ul>
<li><code>-XX:+或-某个属性值</code></li>
<li>+：表示开启；-表示关闭</li>
</ul>
<ol>
<li>是否打印GC收集细节<ul>
<li><code>-XX:-PrintGCDetails</code></li>
<li><code>-XX:+PrintGCDetails</code></li>
</ul>
</li>
<li>是否使用串行垃圾回收器<ul>
<li><code>-XX:-UseSerialGC</code></li>
<li><code>-XX:+UseSerialGC</code></li>
</ul>
</li>
</ol>
<h5 id="KV设值类型"><a href="#KV设值类型" class="headerlink" title="KV设值类型"></a>KV设值类型</h5><p>公式：</p>
<ul>
<li><code>-XX:属性key=属性值value</code></li>
</ul>
<p>例如：</p>
<ul>
<li><code>-XX:MetaspaceSize=128m</code></li>
<li><code>-XX:MaxTenuringThreshold=15</code></li>
</ul>
<h5 id="查看当前程序配置"><a href="#查看当前程序配置" class="headerlink" title="查看当前程序配置"></a>查看当前程序配置</h5><p><code>jps</code>：用来查看进程编号</p>
<p>查看单个配置：<code>jinfo -flag 配置项 进程编号</code></p>
<p>查看所有参数：<code>jinfo -flags 进程号</code></p>
<h5 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h5><p>等价于<code>-XX:InitialHeapSize</code></p>
<h5 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h5><p>等价于<code>-XX:MaxHeapSize</code></p>
<h3 id="查看JVM系统默认值"><a href="#查看JVM系统默认值" class="headerlink" title="查看JVM系统默认值"></a>查看JVM系统默认值</h3><h4 id="XX-PrintFlagsInitial"><a href="#XX-PrintFlagsInitial" class="headerlink" title="-XX:+PrintFlagsInitial"></a>-XX:+PrintFlagsInitial</h4><ul>
<li>查看初始默认值</li>
<li><code>java -XX:+PrintFlagsInitial</code></li>
</ul>
<h4 id="XX-PrintFlagsFinal"><a href="#XX-PrintFlagsFinal" class="headerlink" title="-XX:+PrintFlagsFinal"></a>-XX:+PrintFlagsFinal</h4><ul>
<li>查看修改更新</li>
<li><code>java -XX:+PrintFlagsFinal</code></li>
</ul>
<h4 id="默认值修改值区分"><a href="#默认值修改值区分" class="headerlink" title="默认值修改值区分"></a>默认值修改值区分</h4><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BF%AE%E6%94%B9%E5%80%BC.png" style="zoom: 33%;" />

<ul>
<li>有冒号：修改过的</li>
<li>无冒号：默认值</li>
</ul>
<h4 id="边运行边修改并打印"><a href="#边运行边修改并打印" class="headerlink" title="边运行边修改并打印"></a>边运行边修改并打印</h4><p><code>java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m 程序名</code></p>
<h4 id="XX-PrintCommandLineFlags"><a href="#XX-PrintCommandLineFlags" class="headerlink" title="-XX:+PrintCommandLineFlags"></a>-XX:+PrintCommandLineFlags</h4><h3 id="常用基本配置参数"><a href="#常用基本配置参数" class="headerlink" title="常用基本配置参数"></a>常用基本配置参数</h3><h4 id="Xms-1"><a href="#Xms-1" class="headerlink" title="-Xms"></a>-Xms</h4><ul>
<li>初始大小内存，默认为物理内存1/64</li>
<li>等价于<code>-XX:InitialHeapSize</code></li>
</ul>
<h4 id="Xmx-1"><a href="#Xmx-1" class="headerlink" title="-Xmx"></a>-Xmx</h4><ul>
<li>最大分配内存，默认为物理内存1/4</li>
<li>等价于<code>-XX:MaxHeapSize</code></li>
</ul>
<h4 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h4><ul>
<li>设置单个线程栈的大小，一般默认为512k-1024k</li>
<li>等价于<code>-XX:ThreadStackSize</code></li>
</ul>
<h4 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h4><ul>
<li>设置年轻代大小</li>
</ul>
<h4 id="XX-MetaspaceSize"><a href="#XX-MetaspaceSize" class="headerlink" title="-XX:MetaspaceSize"></a>-XX:MetaspaceSize</h4><ul>
<li>设置元空间大小<ul>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现</li>
<li>两者最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong></li>
<li>因此，默认情况下，元空间的大小仅受本地内存的限制</li>
</ul>
</li>
</ul>
<h4 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h4><ul>
<li>输出详细GC收集日志信息</li>
<li>GC</li>
</ul>
<p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/GC.png"></p>
<ul>
<li>Full GC</li>
</ul>
<p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/Full%20GC.png"></p>
<h4 id="XX-SurvivorRatio"><a href="#XX-SurvivorRatio" class="headerlink" title="-XX:SurvivorRatio"></a>-XX:SurvivorRatio</h4><ul>
<li><strong>设置新生代中eden和S0/S1空间的比例</strong></li>
<li>默认：<code>-XX:SurvivorRatio=8,eden:S0:S1=8:1:1</code></li>
<li>例如：<code>-XX:SurvivorRatio=4,eden:S0:S1=4:1:1</code></li>
<li>SurvivorRatio值就是设置eden区的比例占多少，S0/S1相同</li>
</ul>
<h4 id="XX-NewRatio"><a href="#XX-NewRatio" class="headerlink" title="-XX:NewRatio"></a>-XX:NewRatio</h4><ul>
<li><strong>配置年轻代与老年代在堆结构的占比</strong></li>
<li>默认：<code>-XX:NewRatio=2</code>：新生代占1，老年代2，年轻代占整个堆的1/3</li>
<li>例如：`-XX:NewRatio=4：新生代占1，老年代4，年轻代占整个堆的1/5</li>
<li>NewRatio值就是设置老年代的占比，剩下的1给新生代</li>
</ul>
<h4 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h4><ul>
<li><strong>设置垃圾最大年龄</strong></li>
<li>只能设置为0-15之间</li>
</ul>
<h2 id="四大引用"><a href="#四大引用" class="headerlink" title="四大引用"></a>四大引用</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%BC%95%E7%94%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" style="zoom:50%;" />

<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p><strong>默认支持模式</strong></p>
<ul>
<li>当内存不足，JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收，死都不收</strong>。</li>
</ul>
<p>强引用就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java中最常见的就是强引用，把一个对象赋值给一个引用变量，这个变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，<strong>即使该对象以后永远不会被用到</strong>，JVM也不会回收，因此<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域活着显式的将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾收集策略）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-13 20:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object(); <span class="comment">//强引用</span></span><br><span class="line">        Object o2 = o1; <span class="comment">//o2引用赋值</span></span><br><span class="line">        o1 = <span class="keyword">null</span>; <span class="comment">//置空</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回收o1，o2正常（不回收）</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p>
<p>对于只有软引用的对象来说：</p>
<ul>
<li><strong>当系统内存充足时，它，不会，被回收</strong></li>
<li><strong>当系统内存不足时，它，会，被回收</strong></li>
</ul>
<p>软引用<strong>通常用在对内存敏感的程序中</strong>，比如<strong>高速缓存</strong>（用到了软引用），内存够用的时候就保留，不够就回收。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短</p>
<p>对于只有弱引用的对象来说，<strong>只要垃圾回收机制一运行，不管JVM内存空间是否足够，都会回收该对象的内存</strong>。</p>
<h3 id="软-弱引用适用场景"><a href="#软-弱引用适用场景" class="headerlink" title="软/弱引用适用场景"></a>软/弱引用适用场景</h3><p>假如有一个应用需要读取大量本地图片：</p>
<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能</li>
<li>如果一次性全部加载到内存中又可能造成内存溢出</li>
</ul>
<p>此时，使用软引用可以解决这个问题。</p>
<p>设计思路：用一个HashMap来保存图片路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效避免了OOM的问题。</p>
<p><code>Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</code></p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-13 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">myHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myWeakHashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WeakHashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">        Integer key = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">        String value = <span class="string">&quot;HashMap&quot;</span>;</span><br><span class="line"></span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        key = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        myHashMap();</span><br><span class="line">        System.out.println(<span class="string">&quot;==============&quot;</span>);</span><br><span class="line">        myWeakHashMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;1=HashMap&#125;</span><br><span class="line">&#123;1=HashMap&#125;</span><br><span class="line">&#123;1=HashMap&#125;</span><br><span class="line">============</span><br><span class="line">&#123;2=HashMap&#125;</span><br><span class="line">&#123;2=HashMap&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用需要java.lang.ref.PhantomReference类来实现。</p>
<p>顾名思义，就是形同虚设，与其他引用都不同，<strong>虚引用并不会决定对象的生命周期</strong>。</p>
<p><strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，虚引用<strong>必须和引用队列（ReferenceQueue）联合使用</strong>。</p>
<p>虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。</p>
<p><strong>PhantomReference的get方法总是返回null</strong>，因此无法访问对应的引用对象，其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p>
<p><strong>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</strong></p>
<p>Java技术允许使用<code>finalize()</code>方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p>
<p><strong>总结：被回收前放到引用队列里保存下，做一些后续处理，类似于后置通知！</strong></p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8.png" alt="截屏2023-04-13 21.51.33" style="zoom:50%;" />

<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><h3 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h3><p><strong>Error！</strong>方法太深，出不来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowErrorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackOverflowError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackOverflowError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h3><h4 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h4><p><strong>Error！</strong>对象太多，撑爆了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-14 20:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHeapSpaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;小新&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">111</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">222</span>);</span><br><span class="line">            str.intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h4><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/GC%20overhead%20limit%20exceeded.png" style="zoom:33%;" />

<p>GC回收时间过长时会抛出OutOfMemoryError。</p>
<p>过长的定义是，超过98%的时间都用来做GC并且回收了不到2%的堆内存，连续多次GC，都只回收了不到2%的极端情况下才会抛出。</p>
<p>假如不抛出GC overhead limit exceeded错误会发生什么情况呢？</p>
<ul>
<li>GC清理的这么点内存很快就会再次被填满，迫使GC再次执行，这样就形成了恶性循环，CPU使用率一直都是100%，而GC却没有任何的效果。</li>
</ul>
<p>加上：<code>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liuwq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-04-14 20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCOverheadLimitDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                list.add(String.valueOf(++i).intern());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******** i:&quot;</span> + i);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/GC%20overhead%20limit%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png" style="zoom: 50%;" />

<h4 id="Direct-buff-memory"><a href="#Direct-buff-memory" class="headerlink" title="Direct buff memory"></a>Direct buff memory</h4><p>写NIO程序经常使用ByteBuffer来读取或者写入数据，这是一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<ul>
<li><code>ByteBuffer.allocate(capability)</code>：第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢</li>
<li><code>ByteBuffer.allocateDirect(capability)</code>：第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相对较快</li>
</ul>
<p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，这样堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，程序就直接崩溃了。</p>
<h4 id="unable-to-create-new-native-thread"><a href="#unable-to-create-new-native-thread" class="headerlink" title="unable to create new native thread"></a>unable to create new native thread</h4><p><strong>高并发请求服务器时</strong>，经常会出现这个错误。准确地讲，该错误与对应的平台有关。</p>
<p>导致原因：</p>
<ul>
<li>你的应用创建了太多线程了，一个应用进程创建多个线程，超过系统承载的极限</li>
<li>你的服务器并不允许你的应用程序创建这么多的线程，LInux系统默认允许单个进程可以创建的线程数是1024个，要是超过了，就会出现这个错误</li>
</ul>
<p>解决方法：</p>
<ul>
<li>想办法降低你应用程序创建线程的数量，分析应用是否真的需要创建这么多的线程，如果不是，改代码将线程数降到最低</li>
<li>对于有的应用，确实需要创建很多的线程，远超过Linux系统的默认1024个线程的限制，可以通过修改Linux服务器配置，扩大Linux默认限制</li>
</ul>
<h4 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h4><p>Java8及以后的版本，使用Metaspace来替代永久代。</p>
<p>Metaspace是方法区在HotSpot中的实现，它与持久代最大的区别在于：</p>
<ul>
<li><strong>Metaspace并不在虚拟机内存中，而是在本地内存中</strong></li>
</ul>
<p>永久代（Java8以后被元空间Metaspace取代了）存放了以下信息：</p>
<ul>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul>
<h2 id="GC回收算法和收集器的关系"><a href="#GC回收算法和收集器的关系" class="headerlink" title="GC回收算法和收集器的关系"></a>GC回收算法和收集器的关系</h2><h3 id="分别是什么"><a href="#分别是什么" class="headerlink" title="分别是什么"></a>分别是什么</h3><p>GC算法（引用计数、复制、标清、标整）是内存回收的<strong>方法论</strong>，垃圾收集器是算法的落地<strong>实现</strong>。</p>
<p>因为目前为止还没有完美的收集器出现，更加没有万能的收集器，只是针对具体应用选择最合适的收集器，进行<strong>分代收集</strong>。</p>
<h3 id="4种主要垃圾收集器"><a href="#4种主要垃圾收集器" class="headerlink" title="4种主要垃圾收集器"></a>4种主要垃圾收集器</h3><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/4%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:50%;" />

<ol>
<li>串行垃圾回收器（Serial）</li>
</ol>
<p>它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以<strong>不适合服务器环境</strong></p>
<ol start="2">
<li>并行垃圾回收器（Parallel）</li>
</ol>
<p>多个垃圾收集线程并行工作，此时用户线程是暂停的，<strong>适用于科学计算/大数据处理等弱交互场景</strong></p>
<ol start="3">
<li>并发垃圾回收器（CMS）</li>
</ol>
<p>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程</p>
<p><strong>互联网公司多用它，适用于对响应时间有要求的场景</strong></p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%89%8D%E4%B8%89%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png" style="zoom:50%;" />

<ol start="4">
<li>G1垃圾回收器</li>
</ol>
<p>将<strong>堆内存</strong>分割成不同的区域然后并发的对其进行垃圾回收</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a>查看默认的垃圾收集器</h3><p><code>java  -XX:+PrintCommandLineFlags</code></p>
<h3 id="默认的垃圾收集器"><a href="#默认的垃圾收集器" class="headerlink" title="默认的垃圾收集器"></a>默认的垃圾收集器</h3><p>java的gc回收的类型主要有以下这几种：</p>
<ul>
<li><code>UseSerialGC</code></li>
<li><code>UseParallelGC</code></li>
<li><code>UseConcMarkSweepGC</code></li>
<li><code>UseParNewGC</code></li>
<li><code>UseParallelOldGC</code></li>
<li><code>UseG1GC</code></li>
</ul>
<h3 id="7大垃圾收集器"><a href="#7大垃圾收集器" class="headerlink" title="7大垃圾收集器"></a>7大垃圾收集器</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/7%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png"></p>
<p>垃圾收集器就来具体实现这些GC算法并实现内存回收。</p>
<p>不同厂商、不同版本的虚拟机实现差别很大，HotSpot中包含的收集器如下图所示：</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/HotSpot.png" style="zoom:50%;" />

<h4 id="约定参数说明"><a href="#约定参数说明" class="headerlink" title="约定参数说明"></a>约定参数说明</h4><ul>
<li>DefNew：Default New Generation</li>
<li>Tenured：Old</li>
<li>ParNew：Parallel New Generation</li>
<li>PSYoungGen：Parallel Scavenge</li>
<li>ParOldGen：Parallel Old Generation</li>
</ul>
<h4 id="Server-Client"><a href="#Server-Client" class="headerlink" title="Server/Client"></a>Server/Client</h4><ol>
<li>适用范围：只需要掌握Server模式即可，Client模式基本不会用</li>
<li>操作系统<ul>
<li>32位Windows操作系统，不论硬件如何，默认使用Client的JVM模式</li>
<li>32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是Client模式</li>
<li>64位Only Server模式</li>
</ul>
</li>
</ol>
<h4 id="新生代之Serial收集器"><a href="#新生代之Serial收集器" class="headerlink" title="新生代之Serial收集器"></a>新生代之Serial收集器</h4><p>一个单线程的收集器，在进56tr行垃圾收集的时候，必须暂停其他所有的工作线程，直到它收集结束。</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:50%;" />

<p>串行收集器是最古老、最稳定以及效率高的收集器，只使用一个线程去回收，但在其进行垃圾收集的过程中，可能会产生较长的停顿（Stop-The-World状态）。</p>
<p>虽然在垃圾收集的过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，<strong>没有线程交互的开销可以获得最高的单线程垃圾收集效率</strong>，因此，Serial垃圾收集器依然是Java虚拟机运行在Client模式下默认的新生代垃圾收集器。</p>
<p>对应的JVM参数：<code>-XX:+UseSerialGC</code></p>
<p>开启后会使用：Serial（Young区用）+ Serial Old（Old区用）的收集器组合</p>
<p>表示：新生代和老年代都会使用串行的垃圾收集器，新生代使用复制算法，老年代使用标记-整理算法。</p>
<h4 id="新生代之ParNew收集器"><a href="#新生代之ParNew收集器" class="headerlink" title="新生代之ParNew收集器"></a>新生代之ParNew收集器</h4><p>使用多线程进行垃圾回收，在垃圾收集时，会Stop-the-World暂停其他所有的工作线程直到它收集结束。</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%96%B0%E7%94%9F%E4%BB%A3ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:50%;" />

<p>ParNew收集器其实就是<strong>Serial收集器新生代的并行多线程版本</strong>，最常见的<strong>应用场景是配合老年代的CMS GC工作</strong>，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多java虚拟机运行在Server模式下<strong>新生代的默认垃圾收集器</strong>。</p>
<p>常用对应JVM参数：</p>
<ul>
<li><code>-XX:+UseParNewGC</code>：启用ParNew收集器，只影响新生代的收集，不影响老年代</li>
<li>开启上述参数后，会使用ParNew（Young区用）+ Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法</li>
</ul>
<h4 id="新生代之Parallel收集器"><a href="#新生代之Parallel收集器" class="headerlink" title="新生代之Parallel收集器"></a>新生代之Parallel收集器</h4><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E6%96%B0%E7%94%9F%E4%BB%A3Parallel%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:50%;" />

<p>Parallel Scavenge收集器类似ParNew，也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程垃圾收集器，俗称<strong>吞吐量优先收集器</strong>。一句话：<strong>串行收集器在新生代和老年代的并行化</strong>。</p>
<p>它关注的重点是：</p>
<ul>
<li><strong>可控制的吞吐量</strong>（<code>Thoughput=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</code>），高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。</li>
<li><strong>自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别</strong>。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间(<code>-XX:MaxGCPauseMillis</code>)或最大的吞吐量）</li>
</ul>
<p>常用对应JVM参数：</p>
<ul>
<li><code>-XX:+UseParallelGC或-XX:+UseParallelOldGC</code>(可以相互激活)：使用Parallel Scanvenge收集器</li>
<li>开启该参数后：新生代使用复制算法，老年代使用标记-整理算法</li>
</ul>
<h4 id="老年代之ParallelOld收集器"><a href="#老年代之ParallelOld收集器" class="headerlink" title="老年代之ParallelOld收集器"></a>老年代之ParallelOld收集器</h4><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。</p>
<p>在JDK1.6之前，新生代使用Parallel Scavenge收集器，只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge + Serial Old）</p>
<p>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量的要求比较高，JDK1.8后可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old 收集器的搭配策略。在JDK1.8后（Parallel Scavenge + Parallel Old）</p>
<p>JVM常用参数：</p>
<ul>
<li><code>-XX:+UseParallelOldGC</code>：使用Parallel Old收集器，设置该参数后，新生代Parallel + 老年代Parallel Old</li>
</ul>
<h4 id="老年代之CMS收集器"><a href="#老年代之CMS收集器" class="headerlink" title="老年代之CMS收集器"></a>老年代之CMS收集器</h4><p>CMS收集器（Concurrent Mark Sweep：并发标记清除）是<strong>一种以获取最短回收停顿时间为目标的收集器</strong>。</p>
<p>适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短</strong>。</p>
<p>CMS非常适合堆内存大、CPU核数多的服务器端应用，也是<strong>G1出现之前大型应用的首选收集器</strong>。</p>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B9%8BCMS%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:50%;" />

<p>Concurrent Mark Sweep，并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行</p>
<p>JVM常用参数：</p>
<ul>
<li><code>-XX:+UseConcMarkSweepGC</code>：开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开</li>
</ul>
<p>开启该参数后，使用ParNew（Young区用）+ CMS（Old区用）+ Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器</p>
<p><strong>优点：</strong></p>
<ul>
<li>并发收集低停顿</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>并发执行，对CPU资源压力大</li>
<li>采用的标记清除算法会导致大量碎片</li>
</ul>
<h4 id="老年代之Serial-Old收集器"><a href="#老年代之Serial-Old收集器" class="headerlink" title="老年代之Serial Old收集器"></a>老年代之Serial Old收集器</h4><p>Serial Old是Serial垃圾收集器老年代版本，它同样是一个单线程的收集器，使用标记-整理算法，这个收集器也是主要运行在Client默认的Java虚拟机默认的老年代垃圾收集器。</p>
<p>在Server模式下，主要有两个用途（了解，版本已经到8及以后）：</p>
<ul>
<li>在JDK1.5之前版本中，与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge + Serial Old）</li>
<li>作为老年代中，CMS收集器的后备垃圾收集方案</li>
</ul>
<h3 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h3><p>组合的选择：</p>
<ul>
<li>单CPU或小内存，单机程序<ul>
<li><code>-XX:+UseSerialGC</code></li>
</ul>
</li>
<li>多CPU，需要最大吞吐量，如后台计算型应用<ul>
<li><code>-XX:+UseParallelGC</code></li>
<li><code>-XX:+UseParallelOldGC</code></li>
</ul>
</li>
<li>多CPU，追求低停顿时间，需快速响应，如互联网应用<ul>
<li><code>-XX:+UseConcMarkSweepGC</code></li>
<li><code>-XX:+ParNewGC</code></li>
</ul>
</li>
</ul>
<h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><h4 id="以前收集器的特点"><a href="#以前收集器的特点" class="headerlink" title="以前收集器的特点"></a>以前收集器的特点</h4><ul>
<li>年轻代和老年代是各自独立且连续的内存块</li>
<li>年轻代收集使用单eden+S0+S1进行复制算法</li>
<li>老年代收集必须扫描整个老年代区域</li>
<li>都是以尽可能少而快速地执行GC为设计原则</li>
</ul>
<h4 id="G1是什么"><a href="#G1是什么" class="headerlink" title="G1是什么"></a>G1是什么</h4><p>G1（Garbage-First）收集器，是一款<strong>面向服务端应用</strong>的收集器，<strong>应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能满足垃圾收集暂停时间的要求</strong>。另外，它还具有以下特性：</p>
<ul>
<li>像CMS收集器一样，能与应用程序线程并发执行</li>
<li>整理空闲时间更快</li>
<li>需要更多的时间来预测GC停顿时间</li>
<li>不希望牺牲大量的吞吐性能</li>
<li>不需要更大的Java Heap</li>
</ul>
<p> G1收集器的<strong>设计目标是取代CMS收集器</strong>，它与CMS相比，在以下方面表现的更出色：</p>
<ul>
<li><strong>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片</strong></li>
<li>G1的Stop The World（STW）更可控，<strong>G1在停顿时间上添加了预测机制，用户可以指定期望的停顿时间</strong></li>
</ul>
<p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器-G1垃圾收集器。</p>
<p>G1是在2012年才在jdk1.7u4中可用。oracle<strong>官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS</strong>。它是一款面向服务端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换jva8以前的CMS收集器。</p>
<p>主要改变是Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1M到32M不等。一个region有可能属于Eden，Survivor或者Tenured内存区域。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。</li>
<li>G1<strong>整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片</strong>。</li>
<li>宏观上看G1之中不再区分年轻代和老年代。**把内存划分成多个独立的子区域(Rego)**，可以近似理解为一个围棋的棋盘。</li>
<li>G1收集器里面讲整个的内存区都混合在一起了，<strong>但其木身依然在小范围内要进行年轻代和老年代的区分</strong>，保留了新生代和老年代，但它们不再是物理隔离的，而是一部分Regionl的集合且不需要Region是连续的，也就是说依然会采用不同的GC方式来处理不同的区域。</li>
<li>G1虽然也是分代收集器，但整个内存分区<strong>不存在物理上的</strong>年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1<strong>只有逻辑上的分代概念</strong>，或者说每个分区都可能随G1的运行在不同代之间前后切换：</li>
</ol>
<h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="Region区域化垃圾收集器"><a href="#Region区域化垃圾收集器" class="headerlink" title="Region区域化垃圾收集器"></a>Region区域化垃圾收集器</h5><p>最大的好处是：<strong>化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。</strong></p>
<p>区域化内存划片Region,整体编为了一些列不连续的内存区域，避免了全内存区的GC操作。<br>核心思想是将整个堆内存区域分成大小相同的子区域(Region)，在JVM启动时会自动设置这些子区域的大小。<br>在堆的使用上，<strong>G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可</strong>，每个分区也不会固定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB<del>32MB，且必须是2的幂)，默认将整堆分为2048个分区。<br>大小范围在1MB</del>32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G内存</p>
<h5 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h5><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是<strong>小区域收集+形成连续的内存块，避免内存碎片</strong></p>
<ul>
<li>Eden区的数据移动到Survivor[区，假如出现Survivorl区空间不够，Eden区数据会部会晋升到Old区</li>
<li>Survivor区的数据移动到新的Survivor区，部会数据晋升到Old区</li>
<li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行。</li>
</ul>
<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/G1%E6%94%B6%E9%9B%86%E6%AD%A5%E9%AA%A41.png" style="zoom: 50%;" />

<img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/G1%E6%94%B6%E9%9B%86%E6%AD%A5%E9%AA%A42.png" style="zoom: 50%;" />

<h5 id="4步过程"><a href="#4步过程" class="headerlink" title="4步过程"></a>4步过程</h5><ul>
<li>初始标记：只标记GC Rootsf能直接关联到的对象</li>
<li>并发标记：进行GC Roots Tracing的过程</li>
<li>最终标记：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象</li>
<li>筛选回收：根据时间来进行价值最大化的回收</li>
</ul>
<p><img src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/G1%E6%94%B6%E9%9B%864%E6%AD%A5%E8%BF%87%E7%A8%8B.png"></p>
<h4 id="常用配置参数"><a href="#常用配置参数" class="headerlink" title="常用配置参数"></a>常用配置参数</h4><p>三步归纳：<strong>开始G1+设置最大内存+设置最大停顿时间</strong></p>
<p><code>-XX:+UseG1GC</code></p>
<p><code>-Xmx32g</code></p>
<p><code>-XX:MaxGCPauseMillis=100</code>：最大GC停顿时间，单位毫秒，这个是<strong>软目标</strong>，JVM尽可能（但不保证）停顿小于这个时间</p>
<h4 id="和CMS相比的优势"><a href="#和CMS相比的优势" class="headerlink" title="和CMS相比的优势"></a>和CMS相比的优势</h4><ul>
<li><strong>G1没有内存碎片</strong></li>
<li><strong>可以精确的设置停顿</strong>。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿时间去收集垃圾最多的区域。</li>
</ul>
<h2 id="JVMGC结合SpringBoot微服务优化"><a href="#JVMGC结合SpringBoot微服务优化" class="headerlink" title="JVMGC结合SpringBoot微服务优化"></a>JVMGC结合SpringBoot微服务优化</h2><p>JVMGC ——&gt; 调优 ——&gt; SpringBoot微服务的生产部署和调参优化</p>
<ul>
<li>IDEA开发完微服务工程</li>
<li>Maven进行clean、package</li>
<li>要求微服务启动的时候，同时配置JVM/GC的调优参数<ul>
<li>内</li>
<li>外（重点）</li>
</ul>
</li>
<li>公式：<code>java -server jvm各种参数 -jar jar/war包名字</code></li>
</ul>
<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="生产环境服务器变慢，诊断思路和性能评估"><a href="#生产环境服务器变慢，诊断思路和性能评估" class="headerlink" title="生产环境服务器变慢，诊断思路和性能评估"></a>生产环境服务器变慢，诊断思路和性能评估</h2><p><strong>整机：top</strong>（uptime：系统性能命令精简版）</p>
<p><strong>CPU：vmstat</strong>（查看CPU，包含但不限于）</p>
<ul>
<li><code>vmstat -n 2 3</code>（第一个参数：采样的时间间隔数，单位秒；第二个参数：采样的次数）<ul>
<li><code>procs</code><ul>
<li><code>r</code>：运行和等待CPU时间片的进程数</li>
<li><code>b</code>：等待资源的进程数</li>
</ul>
</li>
<li><code>cpu</code><ul>
<li><code>us</code>：用户进程消耗CPU时间百分比</li>
<li><code>sy</code>：内核进程消耗CPU时间百分比</li>
</ul>
</li>
</ul>
</li>
<li><code>mpstat -P ALL 2</code>（查看所有CPU核的信息）</li>
<li><code>pidstat - u 1 -p 进程编号</code>（每个进程使用CPU的用量分解信息）</li>
</ul>
<p><strong>内存：free（一般用free -m）</strong></p>
<p><strong>硬盘：df</strong>（查看磁盘剩余空间，一般用df -h）</p>
<p><strong>磁盘IO：iostat</strong> </p>
<ul>
<li><code>iostat -xdk 2 3</code></li>
<li><code>pidstat -d 采样间隔秒数 -p 进程号</code></li>
</ul>
<p><strong>网络IO：ifstat</strong>（默认本地没有，下载ifstat）</p>
<h2 id="CPU占用过高定位分析"><a href="#CPU占用过高定位分析" class="headerlink" title="CPU占用过高定位分析"></a>CPU占用过高定位分析</h2><p><strong>结合Linux和JDK命令一块分析</strong></p>
<ol>
<li>先用<code>top</code>命令找出CPU占比最高的</li>
<li><code>ps -ef</code>或者<code>jps -l</code>进一步定位，得知是一个怎么样的后台程序给我们惹事</li>
<li><strong>定位到具体线程或者代码</strong><ul>
<li><code>ps -mp 进程号 -o THREAD,tid,time</code><ul>
<li><code>-m</code>：显示所有的线程</li>
<li><code>-p</code>：pid进程使用CPU的时间</li>
<li><code>-o</code>：该参数后是用户自定义格式</li>
</ul>
</li>
</ul>
</li>
<li>将需要的<strong>线程ID</strong>转换为16进制格式（英文小写格式）：<code>printf &quot;%x\n&quot; 线程ID</code></li>
<li><code>jstack 进程ID｜grep tid(16进制线程id小写英文) -A60</code></li>
</ol>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><h2 id="常用词"><a href="#常用词" class="headerlink" title="常用词"></a>常用词</h2><ul>
<li>watch：会持续收到该项目的动态</li>
<li>fork：复制某个项目到自己的GitHub仓库中</li>
<li>star：点赞</li>
<li>clone：将项目下载至本地</li>
<li>follow：关注你感兴趣的作者，会收到他们的动态</li>
</ul>
<h2 id="in限制搜索"><a href="#in限制搜索" class="headerlink" title="in限制搜索"></a>in限制搜索</h2><p><code>xxx关键词 in:name或description或readme</code></p>
<h2 id="star和fork范围搜索"><a href="#star和fork范围搜索" class="headerlink" title="star和fork范围搜索"></a>star和fork范围搜索</h2><p><code>xxx关键词 stars:&gt;数量</code></p>
<p><code>xxx关键词 forks:&gt;数量</code></p>
<p>区间范围：<code>数字1..数字2</code></p>
<h2 id="awesome搜索"><a href="#awesome搜索" class="headerlink" title="awesome搜索"></a>awesome搜索</h2><p><code>awesome 关键词</code></p>
<p>一般用来收集学习、工具、书籍类相关的项目</p>
<h2 id="L数字"><a href="#L数字" class="headerlink" title="#L数字"></a>#L数字</h2><p>给别人指出关键代码的行号</p>
<p><code>地址#L行号</code></p>
<p><code>地址#L行号-L行号</code></p>
<h2 id="T搜索"><a href="#T搜索" class="headerlink" title="T搜索"></a>T搜索</h2><p>进入项目后，按下英文小写t，可以搜索源码</p>
<h2 id="搜索区域活跃用户"><a href="#搜索区域活跃用户" class="headerlink" title="搜索区域活跃用户"></a>搜索区域活跃用户</h2><p><code>location:地址 language:语言</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1096463510@qq.com">小新</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liuwqtech.github.io/2023/04/02/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%AD%A3/">https://liuwqtech.github.io/2023/04/02/面试/八股文/Java面试题第二季/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liuwqTech.github.io" target="_blank">小新's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="http://qn.liuwqtech.top/008i3skNgy1gpw4zwo9g9j30jd0j8wgz.jpg" target="_blank"><img class="post-qr-code-img" src="http://qn.liuwqtech.top/008i3skNgy1gpw4zwo9g9j30jd0j8wgz.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="http://qn.liuwqtech.top/008i3skNgy1gpw504owa0j30ft0im40s.jpg" target="_blank"><img class="post-qr-code-img" src="http://qn.liuwqtech.top/008i3skNgy1gpw504owa0j30ft0im40s.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/02/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F/%E5%AE%9E%E4%B9%A0-%E7%BE%8E%E5%9B%A2%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95/"><img class="prev-cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">实习-美团移动端开发面试</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/02/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%89%E5%AD%A3/"><img class="next-cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java面试题第三季</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/02/面试/八股文/Java50道面试真题/" title="Java50道面试真题"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">Java50道面试真题</div></div></a></div><div><a href="/2023/04/02/面试/准备/阿里菜鸟-后端-面试准备/" title="阿里菜鸟-后端-面试准备"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">阿里菜鸟-后端-面试准备</div></div></a></div><div><a href="/2023/04/02/面试/八股文/Java面试题第三季/" title="Java面试题第三季"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">Java面试题第三季</div></div></a></div><div><a href="/2023/05/08/面试/准备/快手-后端-面试准备/" title="快手-后端-面试准备"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="title">快手-后端-面试准备</div></div></a></div><div><a href="/2023/05/05/面试/准备/微众银行-测开-面试准备/" title="微众银行-测开"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-05</div><div class="title">微众银行-测开</div></div></a></div><div><a href="/2023/04/02/面试/面经/实习-美团移动端开发面试/" title="实习-美团移动端开发面试"><img class="cover" src="http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">实习-美团移动端开发面试</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">V</span><span class="switch-btn"></span><span class="second-comment">a</span></div></div><div class="comment-wrap"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Volatile"><span class="toc-number">1.</span> <span class="toc-text">Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">保证可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">不保证原子性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">1.3.</span> <span class="toc-text">禁止指令重排</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%8E%B7%E5%BE%97%E4%BF%9D%E8%AF%81"><span class="toc-number">1.4.</span> <span class="toc-text">线程安全性获得保证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E5%8F%AF%E4%BB%A5%E7%94%A8volatile"><span class="toc-number">2.</span> <span class="toc-text">什么地方可以用volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BC%9A%E6%9C%89%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">多线程下会有安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FDCL"><span class="toc-number">2.2.</span> <span class="toc-text">单例模式DCL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8Fvolatile%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">单例模式volatile分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS"><span class="toc-number">3.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS-Demo"><span class="toc-number">3.1.</span> <span class="toc-text">CAS Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe"><span class="toc-number">3.2.1.</span> <span class="toc-text">Unsafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">CAS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">CAS缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%95%E5%8F%91"><span class="toc-number">3.4.1.</span> <span class="toc-text">如何引发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">原子引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">时间戳原子引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">集合类不安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">ArrayList线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">问题重现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%8E%B0%E8%B1%A1"><span class="toc-number">4.1.2.</span> <span class="toc-text">故障现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.1.3.</span> <span class="toc-text">导致原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.1.4.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">Set线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%8E%B0%E8%B1%A1-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">故障现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArraySet"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">CopyOnWriteArraySet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">Map线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%8E%B0%E8%B1%A1-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">故障现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-2"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">公平锁&#x2F;非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88%E9%80%92%E5%BD%92%E9%94%81%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">可重入锁（递归锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">代码验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">5.3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">代码验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%EF%BC%89-%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%EF%BC%89-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">5.4.</span> <span class="toc-text">独占锁（写锁）&#x2F;共享锁（读锁）&#x2F;互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">5.4.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">代码验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Before"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">Before</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#After"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">After</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%85%B6%E4%BB%96%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">JUC其他类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">6.1.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E6%99%AF%E5%A4%8D%E7%8E%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">情景复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">6.2.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">6.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-3"><span class="toc-number">6.2.2.</span> <span class="toc-text">代码验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">6.3.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-5"><span class="toc-number">6.3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-4"><span class="toc-number">6.3.2.</span> <span class="toc-text">代码验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-6"><span class="toc-number">7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">7.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%A2%B3%E7%90%86-%E7%A7%8D%E7%B1%BB%E5%88%86%E6%9E%90"><span class="toc-number">7.3.</span> <span class="toc-text">架构梳理+种类分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97api"><span class="toc-number">7.4.</span> <span class="toc-text">阻塞队列api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">7.5.</span> <span class="toc-text">SynchronousQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-7"><span class="toc-number">7.5.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81-5"><span class="toc-number">7.5.2.</span> <span class="toc-text">代码验证</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">7.6.</span> <span class="toc-text">用在哪里</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.6.1.</span> <span class="toc-text">生产者消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%89%88"><span class="toc-number">7.6.1.1.</span> <span class="toc-text">传统版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%89%88"><span class="toc-number">7.6.1.2.</span> <span class="toc-text">阻塞队列版</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.7.</span> <span class="toc-text">Synchronized和Lock的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">7.7.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%A5%BD%E5%A4%84-%E9%94%81%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%9D%A1%E4%BB%B6Condition"><span class="toc-number">7.7.2.</span> <span class="toc-text">Lock好处: 锁绑定多个条件Condition</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.8.</span> <span class="toc-text">Callable接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">8.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A03%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">线程池3个常用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">8.2.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3"><span class="toc-number">8.2.2.</span> <span class="toc-text">了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">8.2.3.</span> <span class="toc-text">重点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors-newFixedThreadPool-int"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">Executors.newFixedThreadPool(int)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors-newSingleThreadExecutor"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">Executors.newSingleThreadExecutor()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executors-newCachedThreadPool"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">Executors.newCachedThreadPool()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A07%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">线程池7大参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#corePoolSize"><span class="toc-number">8.3.1.</span> <span class="toc-text">corePoolSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maximumPoolSize"><span class="toc-number">8.3.2.</span> <span class="toc-text">maximumPoolSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keepAliveTime"><span class="toc-number">8.3.3.</span> <span class="toc-text">keepAliveTime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unit"><span class="toc-number">8.3.4.</span> <span class="toc-text">unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workQueue"><span class="toc-number">8.3.5.</span> <span class="toc-text">workQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadFactory"><span class="toc-number">8.3.6.</span> <span class="toc-text">threadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handler"><span class="toc-number">8.3.7.</span> <span class="toc-text">handler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">线程池底层工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">8.5.</span> <span class="toc-text">线程池的拒绝策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-8"><span class="toc-number">8.5.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%86%85%E7%BD%AE%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">8.5.2.</span> <span class="toc-text">JDK内置的拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">工作中用哪个？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%8B%E5%86%99%E6%94%B9%E9%80%A0%E5%92%8C%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">8.7.</span> <span class="toc-text">线程池手写改造和拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">8.8.</span> <span class="toc-text">线程池合理配置线程数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%86%E9%9B%86%E5%9E%8B"><span class="toc-number">8.8.1.</span> <span class="toc-text">CPU密集型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%AF%86%E9%9B%86%E5%9E%8B"><span class="toc-number">8.8.2.</span> <span class="toc-text">IO密集型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%BC%96%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">死锁编码分析及定位分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-9"><span class="toc-number">9.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">9.2.</span> <span class="toc-text">产生死锁的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">9.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90"><span class="toc-number">9.4.</span> <span class="toc-text">定位分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jps-l"><span class="toc-number">9.4.1.</span> <span class="toc-text">jps -l</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jstack-%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">9.4.2.</span> <span class="toc-text">jstack 进程号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-GC%E5%9B%9E%E9%A1%BE"><span class="toc-number">10.</span> <span class="toc-text">JVM&#x2F;GC回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">JVM体系概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8%E4%BB%A5%E5%90%8E%E7%9A%84JVM"><span class="toc-number">10.1.2.</span> <span class="toc-text">Java8以后的JVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">10.2.</span> <span class="toc-text">GC的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">常见的垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">10.3.2.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-number">10.3.3.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">10.3.4.</span> <span class="toc-text">标记整理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-GC%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">JVM&#x2F;GC面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC-Roots"><span class="toc-number">11.1.</span> <span class="toc-text">GC Roots</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">11.2.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.1.</span> <span class="toc-text">JVM的参数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%85%8D%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.1.1.</span> <span class="toc-text">标配参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.1.2.</span> <span class="toc-text">X参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.1.3.</span> <span class="toc-text">XX参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.1.3.1.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KV%E8%AE%BE%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.2.1.3.2.</span> <span class="toc-text">KV设值类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">11.2.1.3.3.</span> <span class="toc-text">查看当前程序配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Xms"><span class="toc-number">11.2.1.3.4.</span> <span class="toc-text">-Xms</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Xmx"><span class="toc-number">11.2.1.3.5.</span> <span class="toc-text">-Xmx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BJVM%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">11.2.2.</span> <span class="toc-text">查看JVM系统默认值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintFlagsInitial"><span class="toc-number">11.2.2.1.</span> <span class="toc-text">-XX:+PrintFlagsInitial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintFlagsFinal"><span class="toc-number">11.2.2.2.</span> <span class="toc-text">-XX:+PrintFlagsFinal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BF%AE%E6%94%B9%E5%80%BC%E5%8C%BA%E5%88%86"><span class="toc-number">11.2.2.3.</span> <span class="toc-text">默认值修改值区分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E8%BF%90%E8%A1%8C%E8%BE%B9%E4%BF%AE%E6%94%B9%E5%B9%B6%E6%89%93%E5%8D%B0"><span class="toc-number">11.2.2.4.</span> <span class="toc-text">边运行边修改并打印</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintCommandLineFlags"><span class="toc-number">11.2.2.5.</span> <span class="toc-text">-XX:+PrintCommandLineFlags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">11.2.3.</span> <span class="toc-text">常用基本配置参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Xms-1"><span class="toc-number">11.2.3.1.</span> <span class="toc-text">-Xms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xmx-1"><span class="toc-number">11.2.3.2.</span> <span class="toc-text">-Xmx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xss"><span class="toc-number">11.2.3.3.</span> <span class="toc-text">-Xss</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xmn"><span class="toc-number">11.2.3.4.</span> <span class="toc-text">-Xmn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-MetaspaceSize"><span class="toc-number">11.2.3.5.</span> <span class="toc-text">-XX:MetaspaceSize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-PrintGCDetails"><span class="toc-number">11.2.3.6.</span> <span class="toc-text">-XX:+PrintGCDetails</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-SurvivorRatio"><span class="toc-number">11.2.3.7.</span> <span class="toc-text">-XX:SurvivorRatio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-NewRatio"><span class="toc-number">11.2.3.8.</span> <span class="toc-text">-XX:NewRatio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XX-MaxTenuringThreshold"><span class="toc-number">11.2.3.9.</span> <span class="toc-text">-XX:MaxTenuringThreshold</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.</span> <span class="toc-text">四大引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">11.3.1.</span> <span class="toc-text">整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.2.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.3.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.4.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF-%E5%BC%B1%E5%BC%95%E7%94%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.3.5.</span> <span class="toc-text">软&#x2F;弱引用适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WeakHashMap"><span class="toc-number">11.3.6.</span> <span class="toc-text">WeakHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">11.3.7.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM"><span class="toc-number">11.4.</span> <span class="toc-text">OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StackOverflowError"><span class="toc-number">11.4.1.</span> <span class="toc-text">StackOverflowError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutOfMemory"><span class="toc-number">11.4.2.</span> <span class="toc-text">OutOfMemory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-heap-space"><span class="toc-number">11.4.2.1.</span> <span class="toc-text">Java heap space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-overhead-limit-exceeded"><span class="toc-number">11.4.2.2.</span> <span class="toc-text">GC overhead limit exceeded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-buff-memory"><span class="toc-number">11.4.2.3.</span> <span class="toc-text">Direct buff memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unable-to-create-new-native-thread"><span class="toc-number">11.4.2.4.</span> <span class="toc-text">unable to create new native thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metaspace"><span class="toc-number">11.4.2.5.</span> <span class="toc-text">Metaspace</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.5.</span> <span class="toc-text">GC回收算法和收集器的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.5.1.</span> <span class="toc-text">分别是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E7%A7%8D%E4%B8%BB%E8%A6%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.5.2.</span> <span class="toc-text">4种主要垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.1.</span> <span class="toc-text">查看默认的垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.2.</span> <span class="toc-text">默认的垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%A4%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.</span> <span class="toc-text">7大垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">11.6.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">11.6.3.2.</span> <span class="toc-text">约定参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Server-Client"><span class="toc-number">11.6.3.3.</span> <span class="toc-text">Server&#x2F;Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B9%8BSerial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.4.</span> <span class="toc-text">新生代之Serial收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B9%8BParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.5.</span> <span class="toc-text">新生代之ParNew收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B9%8BParallel%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.6.</span> <span class="toc-text">新生代之Parallel收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B9%8BParallelOld%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.7.</span> <span class="toc-text">老年代之ParallelOld收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B9%8BCMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.8.</span> <span class="toc-text">老年代之CMS收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B9%8BSerial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.3.9.</span> <span class="toc-text">老年代之Serial Old收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.4.</span> <span class="toc-text">如何选择垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.5.</span> <span class="toc-text">G1垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%89%8D%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.6.5.1.</span> <span class="toc-text">以前收集器的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">11.6.5.2.</span> <span class="toc-text">G1是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">11.6.5.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1"><span class="toc-number">11.6.5.4.</span> <span class="toc-text">底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Region%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">11.6.5.4.1.</span> <span class="toc-text">Region区域化垃圾收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.6.5.4.2.</span> <span class="toc-text">回收步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E6%AD%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.6.5.4.3.</span> <span class="toc-text">4步过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">11.6.5.5.</span> <span class="toc-text">常用配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8CCMS%E7%9B%B8%E6%AF%94%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">11.6.5.6.</span> <span class="toc-text">和CMS相比的优势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVMGC%E7%BB%93%E5%90%88SpringBoot%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="toc-number">11.7.</span> <span class="toc-text">JVMGC结合SpringBoot微服务优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">12.</span> <span class="toc-text">Linux命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%98%E6%85%A2%EF%BC%8C%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%E5%92%8C%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="toc-number">12.1.</span> <span class="toc-text">生产环境服务器变慢，诊断思路和性能评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%AE%9A%E4%BD%8D%E5%88%86%E6%9E%90"><span class="toc-number">12.2.</span> <span class="toc-text">CPU占用过高定位分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GitHub"><span class="toc-number">13.</span> <span class="toc-text">GitHub</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%AF%8D"><span class="toc-number">13.1.</span> <span class="toc-text">常用词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in%E9%99%90%E5%88%B6%E6%90%9C%E7%B4%A2"><span class="toc-number">13.2.</span> <span class="toc-text">in限制搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#star%E5%92%8Cfork%E8%8C%83%E5%9B%B4%E6%90%9C%E7%B4%A2"><span class="toc-number">13.3.</span> <span class="toc-text">star和fork范围搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#awesome%E6%90%9C%E7%B4%A2"><span class="toc-number">13.4.</span> <span class="toc-text">awesome搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#L%E6%95%B0%E5%AD%97"><span class="toc-number">13.5.</span> <span class="toc-text">#L数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#T%E6%90%9C%E7%B4%A2"><span class="toc-number">13.6.</span> <span class="toc-text">T搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%8C%BA%E5%9F%9F%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7"><span class="toc-number">13.7.</span> <span class="toc-text">搜索区域活跃用户</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('http://qn.liuwqtech.top//%E9%9D%A2%E8%AF%95/%E5%B0%81%E9%9D%A21.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 小新</div><div class="footer_custom_text">Hi, welcome to my <a href="https://liuwqtech.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/a2f109a6.js","daovoice")
</script><script>var isChatBtn = true
daovoice('init', {
  app_id: 'a2f109a6',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener toc scroll 
  window.removeEventListener('scroll', window.tocScrollFn)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    if (false) {
      location.hash && e.request.responseURL !== location.href ? pjax.loadUrl(location.href) : pjax.loadUrl('/404.html')
      return
    }
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>